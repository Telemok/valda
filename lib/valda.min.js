class Valda{static analyse(a,...e){throw new Error("This function must be implemented")}static is(...a){return!this.analyse(...a).name}static whyNot(...a){let e=this.analyse(...a);return!!e.name&&e.cause}static codeWhyNot(...a){let e=this.analyse(...a);return!!e.name&&e.name}static assert(...a){let e=this.analyse(...a);if(e.name){let a=new TypeError(e.cause);if(a.name=e.name,a.cause=e.cause,"function"==typeof e.argument0)return e.argument0(a);throw"string"==typeof e.argument0&&(a.message=e.argument0),a}return e.value}static parse(a,e,...n){valda.object.assert(a,(a=>{throw a.message="first parameter of parse must be object",a}));let t=a[e],l=this.analyse(t,...n);if(l.name){let a=new TypeError(l.cause);if(a.name=l.name,a.cause=l.cause,void 0===l.argument0)throw a;if("function"==typeof l.argument0)return l.argument0(a);throw"string"==typeof l.argument0&&(a.message=l.argument0),a}return l.value}static factory(a){if("function"!=typeof a)throw new Error("callbackAnalyse must be function.");return class extends Valda{static analyse(e,...n){return a(e,...n)}}}}export const valda={};Object.defineProperty(valda,"Valda",{value:Valda,enumerable:!1}),valda.defined=Valda.factory(((a,e)=>{let n={argument0:e};return void 0===a?(n.cause='typeof is "undefined"',n.name="IS_UNDEFINED",n):(n.name=!1,n.value=a,n)})),valda.boolean=Valda.factory(((a,e)=>{let n=valda.defined.analyse(a,e);return n.name||("1"===n.value||1===n.value||!0===n.value||"true"===n.value?n.value=!0:"0"===n.value||0===n.value||!1===n.value||"false"===n.value?n.value=!1:(n.cause='Value not boolean. Only allowed: false, true, 0, 1, "0", "1", "false", "true".',n.name="IS_NOT_BOOLEAN")),n})),valda.number=Valda.factory(((a,e)=>{let n=valda.defined.analyse(a,e);if(!n.name)if("number"==typeof n.value);else if("boolean"==typeof n.value)n.value=n.value-0;else if("string"==typeof n.value){let a=n.value-0;if(a+""===n.value)n.value=a;else{let a=n.value.length>10?n.value.substr(0,10)+"...":n.value;n.cause=`Can not parse string: "${a}" to number.`,n.name="WRONG_STRING_TO_NUMBER"}}else n.cause=`Can not parse wrong type: "${typeof n.value}" to number.`,n.name="WRONG_TYPE_TO_NUMBER";return n})),valda.numberMinMax=Valda.factory(((a,e=Number.NEGATIVE_INFINITY,n=Number.POSITIVE_INFINITY,t)=>{let l=valda.number.analyse(a,t);return l.name||(l.value>=e?l.value<=n||(l.cause=`Value (${l.value}) must be <= (${n})`,l.name="IS_GREATER_MAXIMNUM"):(l.cause=`Value (${l.value}) must be >= (${e})`,l.name="IS_LESS_MINIMUM")),l})),valda.numberMin=Valda.factory(((a,e=Number.NEGATIVE_INFINITY,n)=>valda.numberMinMax.analyse(a,e,Number.POSITIVE_INFINITY,n))),valda.numberMax=Valda.factory(((a,e=Number.POSITIVE_INFINITY,n)=>valda.numberMinMax.analyse(a,Number.NEGATIVE_INFINITY,e,n))),valda.integerMinMax=Valda.factory(((a,e=Number.MIN_SAFE_INTEGER,n=Number.MAX_SAFE_INTEGER,t)=>{let l=valda.numberMinMax.analyse(a,e,n,t);return l.name||l.value%1!=0&&(l.cause=`Value (${l.value}) must be integer.`,l.name="IS_NOT_INTEGER"),l})),valda.integer=Valda.factory(((a,e)=>valda.integerMinMax.analyse(a,Number.MIN_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,e))),valda.integerMin=Valda.factory(((a,e=Number.MIN_SAFE_INTEGER,n)=>valda.integerMinMax.analyse(a,e,Number.MAX_SAFE_INTEGER,n))),valda.integerMax=Valda.factory(((a,e=Number.MAX_SAFE_INTEGER,n)=>valda.integerMinMax.analyse(a,Number.MIN_SAFE_INTEGER,e,n))),valda.object=Valda.factory(((a,e)=>{let n=valda.defined.analyse(a,e);return n.name||("object"!=typeof n.value?(n.cause=`Type (${typeof n.value}) must be "object"`,n.name="IS_NOT_OBJECT"):null===a&&(n.cause=`Type (${typeof n.value}) must be "object" and not null.`,n.name="IS_NULL")),n})),valda.array=Valda.factory(((a,e)=>{let n=valda.object.analyse(a,e);return n.name||n.value instanceof Array||(n.cause="Value not instaceof Array.",n.name="IS_NOT_ARRAY"),n})),valda.uint8Array=Valda.factory(((a,e)=>{let n=valda.object.analyse(a,e);return n.name||n.value.constructor!==Uint8Array&&(n.cause="Value not Uint8Array.",n.name="IS_NOT_UINT8ARRAY"),n})),valda.uint8Array.toHex=Valda.factory(((a,e)=>{let n=valda.object.analyse(a,e);return n.name||(n.value.constructor!==Uint8Array?(n.cause="Value not Uint8Array.",n.name="IS_NOT_UINT8ARRAY"):n.value=valda.uint8Array.toHex.convert(n.value)),n})),valda.uint8Array.toHex.convert=a=>{let e="";for(let n=0;n<a.length;n++)e+=("0"+a[n].toString(16)).slice(-2);return e},valda.string=Valda.factory(((a,e)=>{let n=valda.defined.analyse(a,e);return n.name||"string"!=typeof n.value&&(n.cause=`Typeof value "${typeof n.value}" must be "string".`,n.name="IS_NOT_STRING"),n})),valda.stringMinMax=Valda.factory(((a,e=0,n=Number.MAX_SAFE_INTEGER,t)=>{let l=valda.string.analyse(a,t);return l.name||(l.value.length>=e?l.value<=n||(l.cause=`String length (${l.value.length}) must be <= (${n})`,l.name="STRING_LENGTH_IS_GREATER_MAXIMNUM"):(l.cause=`String length (${l.value.length}) must be >= (${e})`,l.name="STRING_LENGTH_IS_LESS_MINIMUM")),l})),valda.stringMin=Valda.factory(((a,e=0,n)=>valda.stringMinMax.analyse(a,e,Number.MAX_SAFE_INTEGER,n))),valda.stringMax=Valda.factory(((a,e=Number.MAX_SAFE_INTEGER,n)=>valda.stringMinMax.analyse(a,0,e,n))),valda.function=Valda.factory(((a,e)=>{let n=valda.defined.analyse(a,e);return n.name||"function"!=typeof n.value&&(n.cause=`Typeof value "${typeof n.value}" must be "function".`,n.name="IS_NOT_FUNCTION"),n})),valda.extends=Valda.factory(((a,e,n)=>{let t=valda.function.analyse(a,n);return t.name||t.value.prototype instanceof e||("function"==typeof e?(t.cause=`Function must have prototype in "${e.name}".`,t.name="WRONG_PROTOTYPE"):(t.cause=`Wrong prototype, typeof = "${typeof e}".`,t.name="PROTOTYPE_NOT_FUNCTION")),t})),valda.instance=Valda.factory(((a,e,n)=>{let t=valda.object.analyse(a,n);return t.name||t.value instanceof e||("function"==typeof e?(t.cause=`Object must be instance of "${e.name}".`,t.name="MUST_BE_INSTANCEOF"):(t.cause=`Wrong prototype, typeof = "${typeof e}".`,t.name="CLASS_NOT_FUNCTION")),t}));const valdaAssertVarNameRegex=new RegExp(/^([a-zA-Z_]+)([a-zA-Z0-9_]*)$/);valda.varName=Valda.factory(((a,e)=>{let n=valda.string.analyse(a,e);return n.name||valdaAssertVarNameRegex.test(n.value)||(n.cause="must be varname /^([a-zA-Z_]+)([a-zA-Z0-9_]*)$/",n.name="MUST_BE_VARNAME"),n}));const valdaAssertHexRegex=/^([0-9A-F]*)$/i;valda.hex=Valda.factory(((a,e)=>{let n=valda.string.analyse(a,e);return n.name||(n.value.length%2!=0&&(n.cause=`Hex length must be even, but now length = ${n.value.length}`,n.name="HEX_LENGTH_MUST_BE_EVEN"),valdaAssertHexRegex.test(n.value)||(n.cause="must be (/^([0-9A-F]*)$/i",n.name="MUST_BE_HEX")),n})),valda.hexFixed=Valda.factory(((a,e,n)=>{let t=valda.hex.analyse(a,n);return t.name||t.value.length!==2*e&&(t.cause=`Hex string length must be ${2*e} chars or ${e} bytes, but now: ${t.value.length} chars.`,t.name="HEX_OK_LENGTH_BAD"),t})),valda.enum=Valda.factory(((a,e,n)=>{let t=valda.defined.analyse(a,n);return t.name||(e instanceof Set?e.has(t.value)||(t.cause=`key "${t.value}" not found in enum (Set) [${Array.from(e).join(", ")}]`,t.name="NO_KEY_IN_SET"):e instanceof Map?e.has(t.value)||(t.cause=`key "${t.value}" not found in enum (Map) [${Array.from(e,keys()).join(", ")}]`,t.name="NO_KEY_IN_MAP"):e.some((a=>a===t.value))||(t.cause=`key "${t.value}" not found in enum (Array) [${e.join(", ")}]`,t.name="NO_KEY_IN_ENUM")),t})),valda.element=Valda.factory(((a,e)=>{let n=valda.object.analyse(a,e);return n.name||document.body.baseURI!==a.baseURI&&(n.cause="This object must be element with (document.body.baseURI === value.baseURI).",n.name="OBJECT_NOT_ELEMENT"),n}));
