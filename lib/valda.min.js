class Valda{static analyse(e,...a){throw new Error("This function must be implemented")}static is(...e){return!this.analyse(...e).name}static whyNot(...e){let a=this.analyse(...e);return!!a.name&&a.cause}static codeWhyNot(...e){let a=this.analyse(...e);return!!a.name&&a.name}static assert(...e){let a=this.analyse(...e);if(a.name){let e=new TypeError(a.cause);if(e.name=a.name,e.cause=a.cause,"function"==typeof a.argument0)return a.argument0(e);throw"string"==typeof a.argument0&&(e.message=a.argument0),e}return a.value}static parse(e,a,...t){valda.object.assert(e,(e=>{throw e.message="first parameter of parse must be object",e}));let n=e[a],l=this.analyse(n,...t);if(l.name){let e=new TypeError(l.cause);if(e.name=l.name,e.cause=l.cause,void 0===l.argument0)throw e;if("function"==typeof l.argument0)return l.argument0(e);if("string"==typeof l.argument0)throw e.message=l.argument0,e;throw new Error("valda.parse(callback must be string or function)")}return l.value}static factory(e){if("function"!=typeof e)throw new Error("callbackAnalyse must be function.");return class extends Valda{static analyse(a,...t){return e(a,...t)}}}}export const valda={};Object.defineProperty(valda,"Valda",{value:Valda,enumerable:!1}),valda.defined=Valda.factory(((e,a)=>{let t={argument0:a};return void 0===e?(t.cause='typeof is "undefined"',t.name="IS_UNDEFINED",t):(t.name=!1,t.value=e,t)})),valda.boolean=Valda.factory(((e,a)=>{let t=valda.defined.analyse(e,a);return t.name||("1"===t.value||1===t.value||!0===t.value||"true"===t.value?t.value=!0:"0"===t.value||0===t.value||!1===t.value||"false"===t.value?t.value=!1:(t.cause='Value not boolean. Only allowed: false, true, 0, 1, "0", "1", "false", "true".',t.name="IS_NOT_BOOLEAN")),t})),valda.number=Valda.factory(((e,a)=>{let t=valda.defined.analyse(e,a);if(!t.name)if("number"==typeof t.value);else if("boolean"==typeof t.value)t.value=t.value-0;else if("string"==typeof t.value){let e=t.value-0;if(e+""===t.value)t.value=e;else{let e=t.value.length>10?t.value.substr(0,10)+"...":t.value;t.cause=`Can not parse string: "${e}" to number.`,t.name="WRONG_STRING_TO_NUMBER"}}else t.cause=`Can not parse wrong type: "${typeof t.value}" to number.`,t.name="WRONG_TYPE_TO_NUMBER";return t})),valda.numberMinMax=Valda.factory(((e,a=Number.NEGATIVE_INFINITY,t=Number.POSITIVE_INFINITY,n)=>{let l=valda.number.analyse(e,n);return l.name||(l.value>=a?l.value<=t||(l.cause=`Value (${l.value}) must be <= (${t})`,l.name="IS_GREATER_MAXIMNUM"):(l.cause=`Value (${l.value}) must be >= (${a})`,l.name="IS_LESS_MINIMUM")),l})),valda.numberMin=Valda.factory(((e,a=Number.NEGATIVE_INFINITY,t)=>valda.numberMinMax.analyse(e,a,Number.POSITIVE_INFINITY,t))),valda.numberMax=Valda.factory(((e,a=Number.POSITIVE_INFINITY,t)=>valda.numberMinMax.analyse(e,Number.NEGATIVE_INFINITY,a,t))),valda.integerMinMax=Valda.factory(((e,a=Number.MIN_SAFE_INTEGER,t=Number.MAX_SAFE_INTEGER,n)=>{let l=valda.numberMinMax.analyse(e,a,t,n);return l.name||l.value%1!=0&&(l.cause=`Value (${l.value}) must be integer.`,l.name="IS_NOT_INTEGER"),l})),valda.integer=Valda.factory(((e,a)=>valda.integerMinMax.analyse(e,Number.MIN_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,a))),valda.integerMin=Valda.factory(((e,a=Number.MIN_SAFE_INTEGER,t)=>valda.integerMinMax.analyse(e,a,Number.MAX_SAFE_INTEGER,t))),valda.integerMax=Valda.factory(((e,a=Number.MAX_SAFE_INTEGER,t)=>valda.integerMinMax.analyse(e,Number.MIN_SAFE_INTEGER,a,t))),valda.object=Valda.factory(((e,a)=>{let t=valda.defined.analyse(e,a);return t.name||("object"!=typeof t.value?(t.cause=`Type (${typeof t.value}) must be "object"`,t.name="IS_NOT_OBJECT"):null===e&&(t.cause=`Type (${typeof t.value}) must be "object" and not null.`,t.name="IS_NULL")),t})),valda.array=Valda.factory(((e,a)=>{let t=valda.object.analyse(e,a);return t.name||t.value instanceof Array||(t.cause="Value not instaceof Array.",t.name="IS_NOT_ARRAY"),t})),valda.uint8Array=Valda.factory(((e,a)=>{let t=valda.object.analyse(e,a);return t.name||t.value.constructor!==Uint8Array&&(t.cause="Value not Uint8Array.",t.name="IS_NOT_UINT8ARRAY"),t})),valda.string=Valda.factory(((e,a)=>{let t=valda.defined.analyse(e,a);return t.name||"string"!=typeof t.value&&(t.cause=`Typeof value "${typeof t.value}" must be "string".`,t.name="IS_NOT_STRING"),t})),valda.function=Valda.factory(((e,a)=>{let t=valda.defined.analyse(e,a);return t.name||"function"!=typeof t.value&&(t.cause=`Typeof value "${typeof t.value}" must be "function".`,t.name="IS_NOT_FUNCTION"),t})),valda.extends=Valda.factory(((e,a,t)=>{let n=valda.function.analyse(e,t);return n.name||n.value.prototype instanceof a||("function"==typeof a?(n.cause=`Function must have prototype in "${a.name}".`,n.name="WRONG_PROTOTYPE"):(n.cause=`Wrong prototype, typeof = "${typeof a}".`,n.name="PROTOTYPE_NOT_FUNCTION")),n})),valda.instance=Valda.factory(((e,a,t)=>{let n=valda.object.analyse(e,t);return n.name||n.value instanceof a||("function"==typeof a?(n.cause=`Object must be instance of "${a.name}".`,n.name="MUST_BE_INSTANCEOF"):(n.cause=`Wrong prototype, typeof = "${typeof a}".`,n.name="CLASS_NOT_FUNCTION")),n}));const tbrAssertVarNameRegex=new RegExp(/^([a-zA-Z_]+)([a-zA-Z0-9_]*)$/);valda.varName=Valda.factory(((e,a)=>{let t=valda.string.analyse(e,a);return t.name||tbrAssertVarNameRegex.test(t.value)||(t.cause="must be varname /^([a-zA-Z_]+)([a-zA-Z0-9_]*)$/",t.name="MUST_BE_VARNAME"),t}));const tbrAssertHexRegex=/^([0-9A-F]*)$/i;valda.hex=Valda.factory(((e,a)=>{let t=valda.string.analyse(e,a);return t.name||(t.value.length%2!=0&&(t.cause=`Hex length must be even, but now length = ${t.value.length}`,t.name="HEX_LENGTH_MUST_BE_EVEN"),tbrAssertHexRegex.test(t.value)||(t.cause="must be (/^([0-9A-F]*)$/i",t.name="MUST_BE_HEX")),t})),valda.hexFixed=Valda.factory(((e,a,t)=>{let n=valda.hex.analyse(e,t);return n.name||n.value.length!==2*a&&(n.cause=`Hex string length must be ${2*a} chars or ${a} bytes, but now: ${n.value.length} chars.`,n.name="HEX_OK_LENGTH_BAD"),n})),valda.enum=Valda.factory(((e,a,t)=>{let n=valda.defined.analyse(e,t);return n.name||(a instanceof Set?a.has(n.value)||(n.cause=`key "${n.value}" not found in enum (Set) [${Array.from(a).join(", ")}]`,n.name="NO_KEY_IN_SET"):a instanceof Map?a.has(n.value)||(n.cause=`key "${n.value}" not found in enum (Map) [${Array.from(a,keys()).join(", ")}]`,n.name="NO_KEY_IN_MAP"):a.some((e=>e===n.value))||(n.cause=`key "${n.value}" not found in enum (Array) [${a.join(", ")}]`,n.name="NO_KEY_IN_ENUM")),n})),valda.element=Valda.factory(((e,a)=>{let t=valda.object.analyse(e,a);return t.name||document.body.baseURI!==e.baseURI&&(t.cause="This object must be element with (document.body.baseURI === value.baseURI).",t.name="OBJECT_NOT_ELEMENT"),t}));
